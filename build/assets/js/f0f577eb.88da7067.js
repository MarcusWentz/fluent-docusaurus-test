"use strict";(self.webpackChunkshardeum_docs=self.webpackChunkshardeum_docs||[]).push([[3921],{3347:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"introduction/dynamicstatesharding","title":"Dynamic State Sharding","description":"There are two types of State Sharding - Static State Sharding & Dynamic State Sharding.","source":"@site/docs/introduction/dynamicstatesharding.md","sourceDirName":"introduction","slug":"/introduction/dynamicstatesharding","permalink":"/docusaurus-template/introduction/dynamicstatesharding","draft":false,"unlisted":false,"editUrl":"https://github.com/Shardeum/shardeum-docs/tree/master/docs/introduction/dynamicstatesharding.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Dynamic State Sharding","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Sharding","permalink":"/docusaurus-template/introduction/Sharding"},"next":{"title":"Transaction Consensus","permalink":"/docusaurus-template/introduction/consensus"}}');var s=n(4848),r=n(8453);const i={title:"Dynamic State Sharding",sidebar_position:3},o="Dynamic State Sharding",d={},c=[];function h(e){const t={h1:"h1",header:"header",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"dynamic-state-sharding",children:"Dynamic State Sharding"})}),"\n",(0,s.jsxs)(t.p,{children:["There are two types of State Sharding - ",(0,s.jsx)(t.strong,{children:"Static State Sharding"})," & ",(0,s.jsx)(t.strong,{children:"Dynamic State Sharding"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"The most general approach to sharding is to divide the address space of accounts into multiple fixed-size regions called shards, and nodes in the network are assigned to different shards."}),"\n",(0,s.jsx)(t.p,{children:"In a dynamic state sharding system like Shardeum, shards can be reorganized to adapt to changes in network conditions. This may involve splitting or merging shards, adding or removing nodes from shards, or reassigning nodes to different shards. Reorganization can help maintain an optimal balance between the system's load and resources, ensuring that the network operates efficiently and securely. Shard reorganization can be carried out through various algorithms that respond to changes in real time."}),"\n",(0,s.jsx)(t.p,{children:"In Shardeum, each validator covers a unique range of addresses and only needs to execute the transactions it is assigned to and store the respective state changes. Although each validator covers a unique range, some validators also cover the same addresses in the sense of overlap, thus adding a level of redundancy. This ensures that every address in Shardeum has the required redundancy of at least 128 validators."}),"\n",(0,s.jsx)(t.p,{children:"Compared to Static State Sharding, Dynamic State Sharding allows for the number of shards and their composition to change dynamically based on network conditions. This adaptability enables Dynamic State Sharding to better optimize the system's performance and resource allocation making it much more efficient."})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(6540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);