"use strict";(self.webpackChunkshardeum_docs=self.webpackChunkshardeum_docs||[]).push([[3296],{6108:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"faqs/general","title":"General","description":"What is Shardeum?","source":"@site/docs/faqs/general.md","sourceDirName":"faqs","slug":"/faqs/general","permalink":"/docusaurus-template/faqs/general","draft":false,"unlisted":false,"editUrl":"https://github.com/Shardeum/shardeum-docs/tree/master/docs/faqs/general.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"General","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"SupraOracles","permalink":"/docusaurus-template/oracles/supraoracles"},"next":{"title":"Technology","permalink":"/docusaurus-template/faqs/technology"}}');var a=i(4848),r=i(8453);const s={title:"General",sidebar_position:1},o=void 0,h={},d=[{value:"What is Shardeum?",id:"what-is-shardeum",level:2},{value:"What does Shardeum aim for?",id:"what-does-shardeum-aim-for",level:2},{value:"What are the features of Shardeum?",id:"what-are-the-features-of-shardeum",level:2},{value:"How will Shardeum achieve energy efficiency?",id:"how-will-shardeum-achieve-energy-efficiency",level:2},{value:"How will Shardeum achieve auto-scaling?",id:"how-will-shardeum-achieve-auto-scaling",level:2},{value:"How will Shardeum achieve Fast Finality?",id:"how-will-shardeum-achieve-fast-finality",level:2},{value:"How will Shardeum achieve Low Data Bandwidth?",id:"how-will-shardeum-achieve-low-data-bandwidth",level:2},{value:"How will Shardeum achieve Low latency?",id:"how-will-shardeum-achieve-low-latency",level:2},{value:"How will Shardeum achieve High capacity?",id:"how-will-shardeum-achieve-high-capacity",level:2},{value:"How will Shardeum achieve High fairness?",id:"how-will-shardeum-achieve-high-fairness",level:2},{value:"How will Shardeum achieve High throughput?",id:"how-will-shardeum-achieve-high-throughput",level:2},{value:"What are the types of nodes in Shardeum?",id:"what-are-the-types-of-nodes-in-shardeum",level:2},{value:"Will the Shardeum network work with different wallets?",id:"will-the-shardeum-network-work-with-different-wallets",level:2},{value:"What is Dynamic State Sharding?",id:"what-is-dynamic-state-sharding",level:2},{value:"What is the difference between Shardeum and other similar sharded chains?",id:"what-is-the-difference-between-shardeum-and-other-similar-sharded-chains",level:2}];function l(e){const t={h2:"h2",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"what-is-shardeum",children:"What is Shardeum?"}),"\n",(0,a.jsx)(t.p,{children:"Shardeum is an EVM-based, linearly scalable smart contract platform that provides low gas fees forever while maintaining true decentralization and solid security through dynamic state sharding."}),"\n",(0,a.jsx)(t.h2,{id:"what-does-shardeum-aim-for",children:"What does Shardeum aim for?"}),"\n",(0,a.jsx)(t.p,{children:"Shardeum aims to be a chain capable of onboarding over a billion people to the blockchain and crypto revolution. Shardeum, like the Internet, will be open, collaborative, and community-driven and would democratize accessibility to decentralization."}),"\n",(0,a.jsx)(t.p,{children:"Shardeum will be the infrastructure on which the next iteration of the Internet, Web3, will be built."}),"\n",(0,a.jsx)(t.h2,{id:"what-are-the-features-of-shardeum",children:"What are the features of Shardeum?"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Compute and State Sharding"}),"\n",(0,a.jsx)(t.li,{children:"Smart Contracts"}),"\n",(0,a.jsx)(t.li,{children:"Energy Efficient"}),"\n",(0,a.jsx)(t.li,{children:"Auto Scaling"}),"\n",(0,a.jsx)(t.li,{children:"Security"}),"\n",(0,a.jsx)(t.li,{children:"Immediate finality"}),"\n",(0,a.jsx)(t.li,{children:"Low transaction fees"}),"\n",(0,a.jsx)(t.li,{children:"Low Bandwidth"}),"\n",(0,a.jsx)(t.li,{children:"Low Latency"}),"\n",(0,a.jsx)(t.li,{children:"High Capacity"}),"\n",(0,a.jsx)(t.li,{children:"High Fairness"}),"\n",(0,a.jsx)(t.li,{children:"High Throughput (TPS - Transaction Per Second)"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-energy-efficiency",children:"How will Shardeum achieve energy efficiency?"}),"\n",(0,a.jsx)(t.p,{children:"Energy efficiency means the consensus algorithm used by the network should not require excessive energy beyond what is necessary to process the transactions.\nBitcoin and other networks based on the Nakamoto consensus are designed to use high energy expenditure to secure the network from a 51% attack. However, efficient consensus algorithms such as Paxos and PBFT do not require high energy expenditure. The tradeoff is that these algorithms need the nodes to be assigned a node id before joining the network. Thus, these algorithms have been used in permissioned networks and not for nodes that can participate without requiring a node id.\nShardeum will use an energy-efficient consensus algorithm that requires nodes to have a node id upon joining the network. However, a novel approach does not need a central entity to decide which nodes are part of the network."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-auto-scaling",children:"How will Shardeum achieve auto-scaling?"}),"\n",(0,a.jsx)(t.p,{children:"Auto-scaling means that the network should self-govern the number of nodes the network needs and properly incentivize nodes to achieve the desired size. This implies that the network can effectively use the available nodes to achieve desired tradeoffs, for example, scaling of throughput proportional to the number of nodes available. Otherwise, there is no benefit in a network trying to auto-scale."}),"\n",(0,a.jsx)(t.p,{children:"In networks like Bitcoin, there are conflicts in the desired size of the network. The low bandwidth requirement would favor having as few nodes as possible. In contrast, the high security and decentralization requirement would prefer having as many (unrelated) nodes as possible.\nShardeum will aim to build a network that can auto-scale."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-fast-finality",children:"How will Shardeum achieve Fast Finality?"}),"\n",(0,a.jsx)(t.p,{children:"Fast finality means having a quick turnaround time between submitting a transaction to the network and knowing that the transaction is irreversible.\nIn networks like Bitcoin, there is a probabilistic finality time. The longer you wait, the lower the chance that a transaction confirmed in a block cannot be reversed. Thus, the finality time is not just for the transaction being included in a block. Still, some blocks are being produced after that to reduce the probability of the transaction being reversed. For large value transfers on the Bitcoin network, it is recommended to wait for at least six blocks (about an hour) to ensure irreversibility.\nShardeum aims to provide immediate finality meaning that finality time is the same as latency time of a few seconds."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-low-data-bandwidth",children:"How will Shardeum achieve Low Data Bandwidth?"}),"\n",(0,a.jsx)(t.p,{children:"Low bandwidth means that the network should minimize the amount of data transfer needed when distributing transactions and achieving consensus.\nThis does not imply just compressing the data or using binary formats; instead, the more critical factors are network architecture and algorithmic details of the consensus algorithm. In bitcoin-like networks, adding more nodes increases the amount of bandwidth used to process each transaction.\nShardeum will aim to create a network where the amount of bandwidth consumed by a transaction is constant and does not increase proportionally to the number of nodes."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-low-latency",children:"How will Shardeum achieve Low latency?"}),"\n",(0,a.jsx)(t.p,{children:"Low latency means the total turnaround time between submitting a valid transaction to the network and knowing that the network has committed to the transaction in a short period of time."}),"\n",(0,a.jsx)(t.p,{children:"In networks like Bitcoin, latency is the time between submitting the transaction and including it in a block. For such networks, the fastest latency is no less than the average block production time which is around 10 minutes."}),"\n",(0,a.jsx)(t.p,{children:"Shardeum will provide a latency of just a few seconds by processing each transaction individually before grouping them into blocks."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-high-capacity",children:"How will Shardeum achieve High capacity?"}),"\n",(0,a.jsx)(t.p,{children:"High capacity means that the network should provide persistent storage for massive amounts of state data. Global-scale applications could require exabytes of state data. The current blockchains and distributed ledgers appear to be functional only because they have not been stressed in this dimension.\nShardeum will aim to build a network that can horizontally scale throughput and capacity."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-high-fairness",children:"How will Shardeum achieve High fairness?"}),"\n",(0,a.jsx)(t.p,{children:"High fairness means that a transaction received by the network earlier than another one should be processed accordingly."}),"\n",(0,a.jsx)(t.p,{children:"In a blockchain-based network, transactions within a block are considered to have occurred simultaneously, and the order in which they are applied does not matter. For some applications like games, this does not provide sufficient time resolution. Also, it is possible for transactions that were received much later to be processed before earlier transactions. In bitcoin-like networks, you can get priority by paying more gas."}),"\n",(0,a.jsx)(t.p,{children:"Shardeum will aim to create a network that processes and applies transactions in the order received."}),"\n",(0,a.jsx)(t.h2,{id:"how-will-shardeum-achieve-high-throughput",children:"How will Shardeum achieve High throughput?"}),"\n",(0,a.jsx)(t.p,{children:"High throughput means that the network should process a vast number of transactions per second.\nIn networks like Bitcoin, where every node must process every transaction (i.e., validate and apply), the bottleneck is the processing power of the slowest full nodes. If the bitcoin network were to increase the self-imposed block size limit, it would run into a more natural bottleneck of processing power. The only way to speed up the network would be to raise the processing power of all the nodes (vertical scaling). So all networks where every full node must process every transaction have the same theoretical throughput limit."}),"\n",(0,a.jsx)(t.p,{children:"But in actuality, we see considerable differences when comparing networks like Bitcoin, Litecoin, and Dash. These differences are mainly due to different self-imposed block size limits and block rates. If devs removed these self-imposed limits, the differences due to different consensus algorithms would start to appear. Networks that used proof-of-stake would be much faster than networks that used proof-of-work since the node's processing power is not being used up by proof-of-work computation. Ideally, the rate at which the network processes transactions should be proportional to the number of nodes in the network. Increasing throughput means increasing the number of nodes (horizontal scaling).\nShardeum will aim to build a horizontally scalable network."}),"\n",(0,a.jsx)(t.h2,{id:"what-are-the-types-of-nodes-in-shardeum",children:"What are the types of nodes in Shardeum?"}),"\n",(0,a.jsx)(t.p,{children:"It's still a WIP, but tentatively we will end up having three types of nodes in Shardeum:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Validator Nodes:"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"These nodes validate the transactions in the network by participating in the consensus. They will have to stake SHM to be able to participate. Shardeum will reward them SHM for participating (network rewards will come from predefined SHM emissions, and the transaction fees earned). Validator nodes don't store the whole history, so they are lightweight."}),"\n",(0,a.jsxs)(t.ol,{start:"2",children:["\n",(0,a.jsx)(t.li,{children:"Archive Nodes:"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Archive nodes maintain the entire Transaction history.\nArchive nodes may or may not have to stake SHM (WIP), but they will earn a portion of the network reward (WIP) to incentivize these nodes to store historical data."}),"\n",(0,a.jsxs)(t.ol,{start:"3",children:["\n",(0,a.jsx)(t.li,{children:"Standby Nodes:"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"These are Validator nodes standing by in the network and not currently participating in consensus. Standby nodes help scale the Shardeum network quicker in times of traffic spikes. They may or may not need to stake SHM (WIP), but they will earn a portion of the network rewards (WIP)\nAgain, all of these are WIP. This is just a peek into an overview of how the node ecosystem in Shardeum has been designed."}),"\n",(0,a.jsx)(t.h2,{id:"will-the-shardeum-network-work-with-different-wallets",children:"Will the Shardeum network work with different wallets?"}),"\n",(0,a.jsx)(t.p,{children:"Any EVM based wallet will work on Shardeum. Developers can also build new Shardeum wallets as a dApp utility on the network."}),"\n",(0,a.jsx)(t.h2,{id:"what-is-dynamic-state-sharding",children:"What is Dynamic State Sharding?"}),"\n",(0,a.jsx)(t.p,{children:"Unlike static state sharding where all the nodes in a shard cover the same address range, dynamic state sharding requires each node to hold a different address range, but there is significant overlap between the addresses covered by nodes. Although dynamic sharding is more complex to implement than static sharding, it allows for true linear scaling. Each node added to the Shardeum network immediately helps to increase the TPS, whereas with static sharding the number of nodes that must join has to be at least the number of nodes defined as the minimum shard size before another shard can be created. Only when another shard is created does the network TPS increase in a stepwise way with static sharding."}),"\n",(0,a.jsx)(t.h2,{id:"what-is-the-difference-between-shardeum-and-other-similar-sharded-chains",children:"What is the difference between Shardeum and other similar sharded chains?"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Features"}),(0,a.jsx)(t.th,{children:"Shardeum"}),(0,a.jsx)(t.th,{children:"Harmony"}),(0,a.jsx)(t.th,{children:"Near"}),(0,a.jsx)(t.th,{children:"Elrond"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"EVM Compatible"}),(0,a.jsx)(t.td,{children:"Yes"}),(0,a.jsx)(t.td,{children:"Yes"}),(0,a.jsx)(t.td,{children:"via Aurora"}),(0,a.jsx)(t.td,{children:"No (WASM)"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Smart Contract Language"}),(0,a.jsx)(t.td,{children:"Solidity, Vyper"}),(0,a.jsx)(t.td,{children:"Solidity, Vyper"}),(0,a.jsx)(t.td,{children:"Rust"}),(0,a.jsx)(t.td,{children:"C, C++, C#, Rust"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Explorer"}),(0,a.jsx)(t.td,{children:"EtherScan-like"}),(0,a.jsx)(t.td,{children:"Custom"}),(0,a.jsx)(t.td,{children:"Custom"}),(0,a.jsx)(t.td,{children:"Custom"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Tx Fees in $"}),(0,a.jsx)(t.td,{children:"Very Low & Constant"}),(0,a.jsx)(t.td,{children:"0.000001"}),(0,a.jsx)(t.td,{children:"0.00044"}),(0,a.jsx)(t.td,{children:"0.005"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Txs Per Second (TPS)"}),(0,a.jsx)(t.td,{children:"1 per node (100k TPS @ 100k nodes)"}),(0,a.jsx)(t.td,{children:"2k per shard (8k TPS @ 4 shards)"}),(0,a.jsx)(t.td,{children:"10k per shard (100k TPS @10 shards)"}),(0,a.jsx)(t.td,{children:"3.75k per shard (15k TPS @ 4 shards)"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Nodes per Shard"}),(0,a.jsx)(t.td,{children:"128"}),(0,a.jsx)(t.td,{children:"250"}),(0,a.jsx)(t.td,{children:"100"}),(0,a.jsx)(t.td,{children:"800"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Latency"}),(0,a.jsx)(t.td,{children:"10 Sec always for EIP2930 txs"}),(0,a.jsx)(t.td,{children:"10 Sec per involved shard"}),(0,a.jsx)(t.td,{children:"10 Sec per involved shard"}),(0,a.jsx)(t.td,{children:"10 Sec per involved shard"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Consensus Algorithm"}),(0,a.jsx)(t.td,{children:"PoQ + PoS"}),(0,a.jsx)(t.td,{children:"FBFT"}),(0,a.jsx)(t.td,{children:"PBFT"}),(0,a.jsx)(t.td,{children:"SPoS"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Consensus Level"}),(0,a.jsx)(t.td,{children:"Transaction"}),(0,a.jsx)(t.td,{children:"Block"}),(0,a.jsx)(t.td,{children:"Block"}),(0,a.jsx)(t.td,{children:"Block"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Current Shards"}),(0,a.jsx)(t.td,{children:"NA"}),(0,a.jsx)(t.td,{children:"4 but contracts on 1"}),(0,a.jsx)(t.td,{children:"1 unsharded"}),(0,a.jsx)(t.td,{children:"3 + metachain"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Sharding Type"}),(0,a.jsx)(t.td,{children:"Dynamic"}),(0,a.jsx)(t.td,{children:"Static"}),(0,a.jsx)(t.td,{children:"Static"}),(0,a.jsx)(t.td,{children:"Static"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Scaling Type"}),(0,a.jsx)(t.td,{children:"Linear TPS per node"}),(0,a.jsx)(t.td,{children:"Stepwise TPS per shard"}),(0,a.jsx)(t.td,{children:"Stepwise TPS per shard"}),(0,a.jsx)(t.td,{children:"Stepwise TPS per shard"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Archive Nodes"}),(0,a.jsx)(t.td,{children:"Yes"}),(0,a.jsx)(t.td,{children:"No"}),(0,a.jsx)(t.td,{children:"No"}),(0,a.jsx)(t.td,{children:"No"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Cross Shard Composability"}),(0,a.jsx)(t.td,{children:"Yes"}),(0,a.jsx)(t.td,{children:"No"}),(0,a.jsx)(t.td,{children:"No"}),(0,a.jsx)(t.td,{children:"No"})]})]})]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>o});var n=i(6540);const a={},r=n.createContext(a);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);